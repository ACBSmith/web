#!/usr/bin/php
<?
require_once('/standardebooks.org/web/lib/Core.php');

use function Safe\mkdir;

$longopts = ['webroot:'];
$options = getopt('', $longopts);
$webRoot = $options['webroot'] ?? WEB_ROOT;

$types = ['epub', 'epub-advanced', 'azw3', 'kepub', 'xhtml'];
$groups = ['collections', 'subjects', 'authors', 'months'];
$ebooksByGroup = [];
$updatedByGroup = [];

function CreateZip(string $filePath, array $ebooks, string $type, string $webRoot): void{
	$tempFilename = tempnam(sys_get_temp_dir(), "se-ebooks");

	$zip = new ZipArchive();

	if($zip->open($tempFilename, ZipArchive::CREATE) !== true){
		print('Can\'t open file: ' . $tempFilename . "\n");
	}

	foreach($ebooks as $ebook){
		if($type == 'epub' && $ebook->EpubUrl !== null){
			$ebookFilePath = $webRoot . '/' . $ebook->EpubUrl;
			$zip->addFile($ebookFilePath, basename($ebookFilePath));
		}

		if($type == 'azw3' && $ebook->Azw3Url !== null){
			$ebookFilePath = $webRoot . '/' . $ebook->Azw3Url;
			$zip->addFile($ebookFilePath, basename($ebookFilePath));
		}

		if($type == 'kepub' && $ebook->KepubUrl !== null){
			$ebookFilePath = $webRoot . '/' . $ebook->KepubUrl;
			$zip->addFile($ebookFilePath, basename($ebookFilePath));
		}

		if($type == 'epub-advanced' && $ebook->AdvancedEpubUrl !== null){
			$ebookFilePath = $webRoot . '/' . $ebook->AdvancedEpubUrl;
			$zip->addFile($ebookFilePath, basename($ebookFilePath));
		}

		if($type == 'xhtml' && $ebook->TextSinglePageUrl !== null){
			$ebookFilePath = $webRoot . '/' . $ebook->TextSinglePageUrl . '.xhtml';

			// Strip the navigation header that was added as part of the deploy process
			$xhtml = file_get_contents($ebookFilePath);
			$xhtml = preg_replace('|<body><header><nav>.+?</nav></header>|ius', '<body>', $xhtml);

			$zip->addFromString(str_replace('single-page', $ebook->UrlSafeIdentifier, basename($ebookFilePath)), $xhtml);
		}
	}

	$zip->close();

	rename($tempFilename, $filePath);

	exec('attr -q -s se-ebook-type -V ' . escapeshellarg($type) . ' ' . escapeshellarg($filePath));
}

// Iterate over all ebooks and arrange them by publication month
foreach(Library::GetEbooksFromFilesystem($webRoot) as $ebook){
	$timestamp = $ebook->Created->format('Y-m');
	$updatedTimestamp = $ebook->Updated->getTimestamp();

	// Add to the 'ebooks by month' list
	if(!isset($ebooksByGroup['months'][$timestamp])){
		$obj = new stdClass();
		$obj->Label = $timestamp;
		$obj->LabelSort = $timestamp;
		$obj->Updated = $updatedTimestamp;
		$obj->Ebooks = [$ebook];

		$ebooksByGroup['months'][$timestamp] = $obj;
	}
	else{
		$ebooksByGroup['months'][$timestamp]->Ebooks[] = $ebook;
		if($updatedTimestamp > $ebooksByGroup['months'][$timestamp]->Updated){
			$ebooksByGroup['months'][$timestamp]->Updated = $updatedTimestamp;
		}
	}

	// Add to the 'books by subject' list
	foreach($ebook->Tags as $tag){
		if(!isset($ebooksByGroup['subjects'][$tag->Name])){
			$obj = new stdClass();
			$obj->Label = $tag->Name;
			$obj->LabelSort = $tag->Name;
			$obj->Updated = $updatedTimestamp;
			$obj->Ebooks = [$ebook];

			$ebooksByGroup['subjects'][$tag->Name] = $obj;
		}
		else{
			$ebooksByGroup['subjects'][$tag->Name]->Ebooks[] = $ebook;
			if($updatedTimestamp > $ebooksByGroup['subjects'][$tag->Name]->Updated){
				$ebooksByGroup['subjects'][$tag->Name]->Updated = $updatedTimestamp;
			}
		}
	}

	// Add to the 'books by collection' list
	foreach($ebook->Collections as $collection){
		if(!isset($ebooksByGroup['collections'][$collection->Name])){
			$obj = new stdClass();
			$obj->Label = $collection->Name;
			$obj->LabelSort = $collection->GetSortedName();
			$obj->Updated = $updatedTimestamp;
			$obj->Ebooks = [$ebook];

			$ebooksByGroup['collections'][$collection->Name] = $obj;
		}
		else{
			$ebooksByGroup['collections'][$collection->Name]->Ebooks[] = $ebook;
			if($updatedTimestamp > $ebooksByGroup['collections'][$collection->Name]->Updated){
				$ebooksByGroup['collections'][$collection->Name]->Updated = $updatedTimestamp;
			}
		}
	}

	// Add to the 'books by author' list
	foreach($ebook->Authors as $author){
		if(!isset($ebooksByGroup['authors'][$author->Name])){
			$obj = new stdClass();
			$obj->Label = $author->Name;
			$obj->LabelSort = $author->SortName;
			$obj->Updated = $updatedTimestamp;
			$obj->Ebooks = [$ebook];

			$ebooksByGroup['authors'][$author->Name] = $obj;
		}
		else{
			$ebooksByGroup['authors'][$author->Name]->Ebooks[] = $ebook;
			if($updatedTimestamp > $ebooksByGroup['authors'][$author->Name]->Updated){
				$ebooksByGroup['authors'][$author->Name]->Updated = $updatedTimestamp;
			}
		}
	}
}

foreach($groups as $group){
	foreach($ebooksByGroup[$group] as $collection){
		$urlSafeCollection = Formatter::MakeUrlSafe($collection->Label);
		$parentDir = $webRoot . '/bulk-downloads/' . $group . '/' . $urlSafeCollection;

		if(!is_dir($parentDir)){
			mkdir($parentDir, 0775, true);
		}

		exec('attr -q -s se-ebook-count -V ' . escapeshellarg(sizeof($collection->Ebooks)) . ' ' . escapeshellarg($parentDir));
		exec('attr -q -s se-label -V ' . escapeshellarg($collection->Label) . ' ' . escapeshellarg($parentDir));
		exec('attr -q -s se-label-sort -V ' . escapeshellarg($collection->LabelSort) . ' ' . escapeshellarg($parentDir));

		foreach($types as $type){
			$filePath =  $parentDir . '/se-ebooks-' . $urlSafeCollection . '-' . $type . '.zip';

			// If the file doesn't exist, or if the content.opf last updated time is newer than the file modification time
			if(!file_exists($filePath) || filemtime($filePath) < $collection->Updated){
				print('Creating ' . $filePath . "\n");

				CreateZip($filePath, $collection->Ebooks, $type, $webRoot);
			}
		}
	}
}
